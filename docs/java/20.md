---
title: NIO专题学习（二）
date: 2019/01/08
tags:
 - java
 - NIO
categories:
 - java
---

接上一篇内容......

## 四、JAVA NIO深入剖析

在讲解利用NIO实现通信架构之前，我们需要先来了解一下NIO的基本特点和使用

### 1. Java NIO基本介绍

- java NlO (New lO）也有人称之为java non-blocking IO，是Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java lO API。 NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持**面向缓冲区**的、**基于通道**的IO操作。NIO将以**更加高效**的方式进行文件的读写操作。NIO可以理解为非阻塞IO，传统的IO 的read和write只能阻塞执行，线程在读写期间不能干其他事情，比如调用socket. read(）时，如果服务器一 直没有数据传输过来，线程就一直阻塞，而<font style="color:red">NIO中可以配置socket为非阻塞模式</font>
- NIO相关类都被放在java.nio包及子包下，并且对原 Java.io 包中的很多类进行改写。
- NIO有三大核心部分：Channel（通道），Buffer(缓冲区），Selector（选择器）
- Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据；<font style="color:red">如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。</font>非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
- 通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有1000个请求过来，根据实际情况，可以分配20或者80个线程来处理。不像之前的阻塞IO那样，非得分配1000个。

### 2. NIO和BIO的比较

- BlO以流的方式处理数据，而NIO以块的方式处理数据，块I/O的效率比流I/O高很多
- BlO是阻塞的，NIO则是非阻塞的
- BlO基于字节流和字符流进行操作，而NIO基于Channel(通道）和Buffer(缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道

![image-20240730151651224](https://bucket-linxc.oss-cn-guangzhou.aliyuncs.com/images/image-20240730151651224.png)

### 3. NIO三大核心原理示意图

NIO有三大核心部分：Channel(通道)，Buffer(缓存区)，Selector(选择器)

#### Buffer缓存区

缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer API更加容易操作和管理。

#### Channel通道

Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的(input或 output)读写通常是单向的。通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。

#### Selector选择器

Selector是一个Java NIO组件，可以能够检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率。
![image-20240730152054016](https://bucket-linxc.oss-cn-guangzhou.aliyuncs.com/images/image-20240730152054016.png)

- 每个channel都会对应一个Buffer
- 一个线程对应Selector，一个Selector对应多个channel（连接）
- 程序切换到哪个channel是由**事件**决定的
- Selector会根据不同的事件，在各个通道上切换
- Buffer就是一个内存块，底层是一个数组
- 数据的读取写入是通过Buffer完成的，BIO中要么是输入流，或者是输出流，不能双向，但是**<font style="color:red">NIO的Buffer是可以读也可以写。</font>**
- Java NIO系统的核心在于：通道（Channel）和缓存区（Buffer)。通道表示打开到IO设备（例如：文件、套接字） 的连接。若需要使用NlO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。**<font style="color:red">简而言之，Channel负责传输，Buffer负责存取数据。</font>**

### 4. NIO核心一：缓存区（Buffer)

#### 缓存区（Buffer）

一个用于特定基本数据类型的容器，由java.nio包定义，所有缓冲区都是Buffer抽象类的子类，Java NIO中的Buffer主要与NIO通道进行交互，数据是从通道读取到缓冲区的，从缓冲区写入到通道的。
![image-20240730152415194](https://bucket-linxc.oss-cn-guangzhou.aliyuncs.com/images/image-20240730152415194.png)

#### Buffer类及其子类

Buffer就像一个数组，可以保存多个相同类型的数据。根据数据类型不同，有以下Buffer常用子类：

- ByteBuffer
- CharBuffer
- ShortBuffer
- IntBuffer
- LongBuffer
- FloatBuffer
- DoubleBuffer

上述Buffer类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个Buffer对象：

```java
static XxxBuffer allocate(int capacity):创建一个容量为capacity的XxxBuffer对象
```

#### 缓存区的基本属性

Buffer中的重要概念：

- **容量（capacity)：**作为一个内存块，Buffer具有一定的固定大小，也称为”容量”，<font style="color:red">缓冲区容量不能为负，并且 创建后不能更改。</font>
- **限制（limit)：**表示缓冲区中可以操作数据的大小（limit后数据不能进行读写）。缓冲区的限制不能为负，并且<font style="color:red">不能大于其容量</font>。写入模式，限制等于buffer的容量。读取模式下，limit等于写入的数据量。
- **位置（position)：**下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制
- **标记（mark）与重置（reset)：**标记是一个索引，通过Buffer中的mark(）方法指定Buffer中一个特定的 position，之后可以通过调用reset(）方法恢复到这个position。标记、位置、限制、容量。遵守以下式：**<font style="color:red">0<=mark<=position<=limit<=capacity</font>**

**图示：**

![image-20240730153159581](https://bucket-linxc.oss-cn-guangzhou.aliyuncs.com/images/image-20240730153159581.png)

#### Buffer常见方法

```java
Buffer clear(）清空缓冲区并返回对缓冲区的引用
Buffer flip(）为将缓冲区的界限设置为当前位置，并将当前位置重置为0
int capacity(）返回Buffer的capacity大小
boolean hasRemaining(）判断缓冲区中是否还有元素
int limit(）返回Buffer的界限（limit）的位置
Buffer limit(int n）将设置缓冲区界限为n，并返回一个具有新limit的缓冲区对象
Buffer mark(）对缓冲区设置标记
int position(）返回缓冲区的当前位置position
Buffer position(int n）将设置缓冲区的当前位置为n，并返回修改后的Buffer对象
int remaining()返回position和limit之间的元素个数
Buffer reset(）将位置position转到以前设置的mark所在的位置
Buffer rewind();将位置设为为0．取消设置的mark
```

#### 缓存区的数据操作

Buffer所有子类提供了两个用于数据操作的方法：get()和put()

**获取Buffer中的数据**

```java
get()：读取单个字节
get (byte[] dst)：批量读取多个字节到dst中
get(int index)：读取指定索引位置的字节（不会移动position)
```

**放入数据到Buffer中**

```java
put(byte b):将给定单个字节写入缓冲区的当前位置
put (byte[] src):将src中的字节写入缓存区的当前位置
put(int index,byte b)L将指定字节写入缓存区的索引位置（不会移动position）
```

**使用Buffer读写数据一般遵循以下四个步骤**

1. 写入数据到Buffer
2. 调用flip()方法，转换为读取模式
3. 从Buffer中读取数据
4. 调用buffer.clear()方法或者buffer.compact()方法清除缓存区

#### 案例演示

```java
import org.junit.Test;
import java.nio.ByteBuffer;
//目标：对缓存区Buffer的常用API进行案例实现
public class BufferTest {
    @Test
    public void test01(){
        //1.设置一个缓冲区，设置容量为10
        ByteBuffer buffer = ByteBuffer.allocate(10);
        System.out.println(buffer.position());//0
        System.out.println(buffer.limit());//10
        System.out.println(buffer.capacity());//10
        System.out.println("-----------------------");
        //2.往缓冲区放入数据
        String name = "linxc";
        buffer.put(name.getBytes());
        System.out.println(buffer.position());//5
        System.out.println(buffer.limit());//10
        System.out.println(buffer.capacity());//10
        System.out.println("-----------------------");
        //3.flip() 将缓冲区的界限设置为当前位置，并将当前位置设置为0 可读模式
        buffer.flip();
        System.out.println(buffer.position());//0
        System.out.println(buffer.limit());//5
        System.out.println(buffer.capacity());//10
        System.out.println("-----------------------");
        //4. get数据的读取
        char ch = (char) buffer.get();
        System.out.println(ch);//l
        System.out.println(buffer.position());//1
        System.out.println(buffer.limit());//5
        System.out.println(buffer.capacity());//10
        //再读一次
        char ch1 = (char) buffer.get();
        System.out.println(ch1);//i
        System.out.println(buffer.position());//2
        System.out.println(buffer.limit());//5
        System.out.println(buffer.capacity());//10
    }

    @Test
    public void test02() {
        //1.分配一个缓存区，容量设置为10
        ByteBuffer buffer = ByteBuffer.allocate(10);
        System.out.println(buffer.position());//0
        System.out.println(buffer.limit());//10
        System.out.println(buffer.capacity());//10
        System.out.println("-----------------------");
        String name = "linxc";
        buffer.put(name.getBytes());
        System.out.println(buffer.position());//5
        System.out.println(buffer.limit());//10
        System.out.println(buffer.capacity());//10
        System.out.println("-----------------------");
        //2.clear 清楚缓存区中的数据
        buffer.clear();
        System.out.println(buffer.position());//0
        System.out.println(buffer.limit());//10
        System.out.println(buffer.capacity());//10
        System.out.println((char) buffer.get());//l 表明数据并没有清除 只是恢复了position的位置
        System.out.println("-----------------------");
        //3.定义一个缓存区
        ByteBuffer buf = ByteBuffer.allocate(10);
        String n = "linxc";
        buf.put(n.getBytes());
        buf.flip();
        //读取数据
        byte[] b = new byte[2];
        buf.get(b);
        String rs = new String(b);
        System.out.println(rs);//li
        System.out.println(buf.position());//2
        System.out.println(buf.limit());//5
        System.out.println(buf.capacity());//10
        System.out.println("-----------------------");
        buf.mark();//标记此刻这个位置：2
        byte[] b2 = new byte[3];
        buf.get(b2);
        System.out.println(new String(b2));//nxc
        System.out.println(buf.position());//5
        System.out.println(buf.limit());//5
        System.out.println(buf.capacity());//10
        System.out.println("-----------------------");
        buf.reset();//回到标记位置 2
        if (buf.hasRemaining()) {
            System.out.println(buf.remaining());//3
        }
    }
}
```

#### 直接与非直接缓存区

什么是直接内存与非直接内存

根据官方文档的描述：

byte buffer。可以是两种类型，一种是基于直接内存（也就是非堆内存）；另一种是非直接内存（也就是堆内存）。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。

**从数据流的角度，非直接内存是下面这样的作用链：**

本地IO--->直接内存--->非直接内存--->直接内存--->本地IO

**而直接内存是：**

本地IO--->直接内存--->本地IO

很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用allocateDirect创建，但是它比申请普通的堆内存需要耗费更高的性能。不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以呢，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其```isDirect()```方法来确定。

**验证代码：**

```java
@Test
    public void test03() {
        //创建非直接内存的缓冲区
        ByteBuffer buf1 = ByteBuffer.allocate(1024);
        //buffer.isDirect()用于判断是否为直接内存
        System.out.println(buf1.isDirect());
        System.out.println("---------------------------");
        //创建直接内存的缓冲区
        ByteBuffer buf2 = ByteBuffer.allocateDirect(1024);
        System.out.println(buf2.isDirect());
    }
```

**执行结果：**

```bash
false
---------------------------
true
```

**使用场景**

1. 有很大的数据需要存储，他的生命周期又很长
2. 适合频繁的IO操作，比如网络并发场景

### 5. NIO核心二：通道（Channel）

#### Channel概述

通道（Channel)：由java.nio.channels包定义的。Channel表示IO源与目标打开的连接。Channel类似于传统的“流”。只不过Channel本身不能直接访问数据，Channel只能与Buffer进行交互。

1. **NIO的通道类似于流，但有些区别如下**

- 通道可以同时进行读写，而流只能读或者只能写
- 通道可以实现异步读写数据
- 通道可以从缓冲读数据，也可以写数据到缓冲

2. **BlO中的stream是单向的，例如FilelnputStream对象只能进行读取数据的操作，而NIO中的通道（Channel）是双向的，可以读操作，也可以写操作。**
3. **Channel在NIO中是一个接口**

```java
public interface Channel extends Closeable()
```

#### 常用的Channel实现类

